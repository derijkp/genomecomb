= Select =

== Format ==
cg select ?options? ?infile? ?outfile?

== Summary ==
Command for very flexible selection, sorting and conversion of tab separated files

== Description ==
Scans a tab separated file with header, and returns selected lines and columns, optionally sorted.
The first line of the file is used as a header containing the field names of each column.
The header line can be proceeded by comment lines that start with #. The comment lines
will be included in the result. Other types of headers are supported (CGI style, vcf style)

== Arguments ==
; **infile**: file to be scanned, if not given, uses stdin. File may be compressed.
; **outfile**: write results to outfile, if not given, uses stdout

== Options ==
; **-q query**: only lines fullfilling conditions in query will be written to outfile (see further)
; **-qf queryfile**: only lines fullfilling conditions in queryfile will be written to outfile (see further)
; **-f fields**: only write given fields to result.
An asterix can be used to indicated several fields matching a pattern.
A field starting with fieldname=formula will add a field with the given fieldname. The value in 
the column will be calculated using the given formula. If the formula is complex (includes spaces), add
braces around the entire field=formula.
; **-rf removefields**: write all, except given fields to result.
; **-s sortfields**: sort on given fields (uses natural sort, so that e.g. 'chr1 chr2 chr10' will be sorted correctly)
; **-nh newheader**: replace header in output with fields given by this option
; **-sh sepheader**: write a resultfile without header, and write the header into the file **sepheader**
; **-hc headerincomment**: if 1, the last of the starting comment lines will be used for the header instead of the first non-comment line
; **-hf headerfile: infile does not have a header, the header will be read from **headerfile** instead
; **-h**: return header fields in file
; **-n**: return sample names in file
The query or field lines can contain more than one line (enclose in '').
Lines starting with a # are comments

== Query ==
In queries, the value of a field for the line can be accessed using a $ followed by the name of the field.
e.g.:
$start > 10000
will only return lines where the field start is larger than 10000. Queries support all operators
and functions provided by awk.

Some extra functions are available:

=== Tools ===
; **min(a1,a2,...)**: returns the minimum of a1, a2, ...
a1, etc. can be a list of numbers (separated by commas, spaces or ;).
If one of the args is not a number it will be replaced by Inf
; **max(a1,a2,...)**: returns the maximum of a1, a2, ...
a1, etc. can be a list of numbers (separated by commas, spaces or ;).
If one of the args is not a number it will be replaced by -Inf
; **oneof($field,value1,cvalue2,...)**: returns true if the given field matches one of the values
The default value for non-numeric arguments can be set e.g. to 1000 by giving def=1000 as the first argument
; **avg(value,...)**: returns the average of the values given. Non-number values are ignored.
If no number was given, the answer will be NaN
; **region("chromosome:begin-end",...)**: is true for any region in dataset that overlaps the given regions.
Can also be given as region(chromosome,begin,end,...).
If the chromosome value in the query or the data file starts with chr, this part is ignored: chr2 will match 2, as wel as Chr2.
; **regexp(value,pattern): true if value matches the regular expression given by **pattern**
=== fields that contain comma separated lists ===
Some fields can contain multiple values in the form of a comma separated list. The following functions allow
using this in queries

; **lmin($field, ...)**: the minimum of the list of numbers (comma or space or ; separated) in field. A default value (Inf) is given for non-numeric characters (-)
; **lmind($field, ..., def)**: same as lmin, but you can set the default value for non-numeric characters is given as the last parameter
; **lmax($field, ...)**: the maximum of the list of numbers (comma or space or ; separated) in field. A default value (-Inf) is given for non-numeric characters (-)
; **lmaxd($field, ..., def)**: same as lmax, but you can set the default value for non-numeric characters is given as the last parameter

=== multifield functions ===
The following functions address multiple fields.

; **count($field1, $field2, ..., test)**: Counts the number of fields that fullfill the test (can be things like: ' == "A"' or '< 20')
; **counthasone($field1, $field2, ..., test)**: Counts the number of fields containing a commma separated lists for which one of the values fullfills the test
; **counthasall($field1, $field2, ..., test)**: Counts the number of fields containing a commma separated lists for which all of the values fullfill the test

An asterix can be used to indicated several fields matching a pattern.
As field names specific to a sample are made by appending with -samplename, something like
count($sequenced-*, == "v")
will give the number of samples for which a variant was found

=== comparing samples ===

; **same(sample1,sample2, ...)**: same: all samples have the same genotype (does not have to be a variant) (all sequenced)
; **sm(sample1,sample2, ...)**: same: variant with the same genotype in all given samples (all sequenced)
; **df(sample1,sample2, ...)**: different: variant in some, reference in other (all sequenced)
; **mm(sample1,sample2, ...)**: mismatch; variant in all, but different genotypes (all sequenced)
; **un(sample1,sample2, ...)**: unsequenced in some samples, variant in one of the others

== Queryfile ==
A queryfile is a tab delimited file with a header describing a query. The output will contain 
resultlines where all values in the columns given in the query header in the resultline are 
equal to the corresponding values given in one line of the query file.

== Category ==
Query

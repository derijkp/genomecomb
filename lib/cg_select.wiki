= Select =

== Format ==
cg select ?options? ?infile? ?outfile?

== Summary ==
Command for very flexible selection, sorting and conversion of tab separated files

== Description ==
Scans a tab separated file with header, and returns selected lines and columns, optionally sorted.
The first line of the file is used as a header containing the field names of each column.
The header line can be proceeded by comment lines that start with #. The comment lines
will be included in the result. Other types of headers are supported (CGI style, vcf style)

== Arguments ==
; **infile**: file to be scanned, if not given, uses stdin. File may be compressed.
; **outfile**: write results to outfile, if not given, uses stdout

== Options ==
; **-q query**: only lines fullfilling conditions in query will be written to outfile (see further)
; **-qf queryfile**: only lines fullfilling conditions in queryfile will be written to outfile (see further)
; **-f fields**: only write given fields to result.
An asterix can be used to indicated several fields matching a pattern.
A field starting with fieldname=formula will add a field with the given fieldname. The value in 
the column will be calculated using the given formula. If the formula is complex (includes spaces), add
braces around the entire field=formula.
; **-rf removefields**: write all, except given fields to result.
; **-s sortfields**: sort on given fields (uses natural sort, so that e.g. 'chr1 chr2 chr10' will be sorted correctly)
if **sortfields** is "-", the default sort fields will be used (chromosome,begin,end,type,alt).
This will also accept name variations of the fields, such as chrom instead of chromosome.
; **-nh newheader**: replace header in output with fields given by this option
; **-sh sepheader**: write a resultfile without header, and write the header into the file **sepheader**
; **-hc headerincomment**: if 1, the last of the starting comment lines will be used for the header instead of the first non-comment line
; **-hf headerfile: infile does not have a header, the header will be read from **headerfile** instead
; **-h**: return header fields in file
; **-n**: return sample names in file
The query or field lines can contain more than one line (enclose in '').
Lines starting with a # are comments

== Query ==
In queries, the value of a field for the line can be accessed using a $ followed by the name of the field.
e.g.:
$start > 10000
will only return lines where the field start is larger than 10000.
The special variable ROW will contain the row number of the current line. $ROW starts at 0 for this 
first line after the header/comments.
e.g.:
$ROW == 1000
will select data line 1000 in the file.
Queries support all operators and functions provided by Tcl expr.

Some extra functions are available:

=== Bio functions ===
; **region("chromosome:begin-end",...)**: is true for any region in dataset that overlaps the given regions.
Can also be given as region(chromosome,begin,end,...).
If the chromosome value in the query or the data file starts with chr, this part is ignored: chr2 will match 2, as wel as Chr2.
; **hovar(samplename)**: true if the given sample is a homozygous variant. This is equivalent to ($sequenced-samplename == "v" && $alleleSeq1-samplename == $alleleSeq2-samplename)

=== Number functions ===
; **between(value,{min max})**: true of value is >= min and <= max (e.g. "between($begin,1000,2000)")
This function can also be used as an operand, eg "$field between {1 2}"
; **min(a1,a2,...)**: returns the minimum of a1, a2, ...
a1, etc. can be a list of numbers (separated by commas, spaces or ;).
If one of the args is not a number it will be replaced by Inf
; **max(a1,a2,...)**: returns the maximum of a1, a2, ...
a1, etc. can be a list of numbers (separated by commas, spaces or ;).
If one of the args is not a number it will be replaced by -Inf
; **avg(value,...)**: returns the average of the values given. Non-number values are ignored.
If no number was given, the answer will be NaN
; **isnum(value)**: true if value is a valid number
; **percent(value)**: returns a fraction as a percent 
; **def(value,default)**: if value is not a number, it returns the given default, otherwise value

=== vector functions (comma separated lists) ===
Some fields can contain multiple values in the form of a comma (or ; or space) separated 
list (further called vector).
The following functions allow use of vectors in queries

; **lmin(vector, ...)**: the minimum of the list of numbers in vector(s). A default value (Inf) is given for non-numeric characters (-)
; **lmind(vector, ..., def)**: same as lmin, but you can set the default value for non-numeric characters is given as the last parameter
; **lminpos(vector, ...)**: position (within the index) of the minimum value. If more than one vector is given, the position of the minimum of all vectors is given
; **lmax(vector, ...)**: the maximum of the vector. A default value (-Inf) is given for non-numeric characters (-)
; **lmaxd(vector, ..., def)**: same as lmax, but you can set the default value for non-numeric characters is given as the last parameter
; **lmaxpos(vector, ...)**: position (within the index) of the maximum value. If more than one vector is given, the position of the maximum of all vectors is given
This can also be used as an operand: vector shares valuelist

; **lindex(vector, position)**: the value of the element at the given **position** in the list. The first element is at position 0!
; **contains(vector, value)**; true if the list in **field** contains **value**. 
This can also be used as an operand: vector contains value
; **shares(vector, valuelist)**; true if the list in **field** and the list in **valuelist** (a SPACE separated list!) share a value.
; **lone(vector)**: true if one of elements of the vector is true
; **lall(vector)**: true if all elements of the vector are true
; **lcount(vector)**: number of elements in vector that are true
; **llen(vector)**: number of elements in the vector

=== vector operators ===
Several special operators are added that work on comma (or ; or space) separated
lists (vectors). The result of such an operator is also a vector. The arguments
to such an operator must be of the same length, or one of them must be of 
length 1. If one of them is of length 1, the same element will be used versus
all elements in the other vector. Supported operators are:
@**, @*, @/, @%, @-, @+, @>, @<, @>=, @<=, @==, @!=

=== vector functions (that return vectors) ===
; **vabs(vector)**: returns vector of absolute values of given vector
; **vavg(vector1,vector2,...)**: returns vector with average value for each position in the vector
; **vmax(vector1,vector2,...)**: returns vector with maximum value for each position in the vector
; **vmin(vector1,vector2,...)**: returns vector with minimum value for each position in the vector
; **vdef(vector,default)**: returns the given vector, but with all non numbers replaced by default

=== String functions ===
; **oneof($field,value1,cvalue2,...)**: returns true if the given field matches one of the values
The default value for non-numeric arguments can be set e.g. to 1000 by giving def=1000 as the first argument
; **regexp(value,pattern)**: true if value matches the regular expression given by **pattern**

=== multifield functions ===
The following functions address multiple fields.

; **count($field1, $field2, ..., test)**: Counts the number of fields that fullfill the test (can be things like: ' == "A"' or '< 20')
; **counthasone($field1, $field2, ..., test)**: Counts the number of fields containing a commma separated lists for which one of the values fullfills the test
; **counthasall($field1, $field2, ..., test)**: Counts the number of fields containing a commma separated lists for which all of the values fullfill the test

An asterix can be used to indicated several fields matching a pattern.
As field names specific to a sample are made by appending with -samplename, something like
count($sequenced-*, == "v")
will give the number of samples for which a variant was found

=== comparing samples ===

; **same(sample1,sample2, ...)**: same: all samples have the same genotype (does not have to be a variant) (all sequenced)
; **sm(sample1,sample2, ...)**: same: variant with the same genotype in all given samples (all sequenced)
; **df(sample1,sample2, ...)**: different: variant in some, reference in other (all sequenced)
; **mm(sample1,sample2, ...)**: mismatch; variant in all, but different genotypes (all sequenced)
; **un(sample1,sample2, ...)**: unsequenced in some samples, variant in one of the others

== Queryfile ==
A queryfile is a tab delimited file with a header describing a query. The output will contain 
resultlines where all values in the columns given in the query header in the resultline are 
equal to the corresponding values given in one line of the query file.

== Category ==
Query

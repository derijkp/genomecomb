#!/bin/sh
# the next line restarts using wish \
exec tclsh "$0" ${1+"$@"}

# see where we are, add the lib dir in the original location to auto_path, load extension
set script [file normalize [info script]]
set scriptname [file tail $script]
while 1 {
	if {[catch {set script [file normalize [file readlink $script]]}]} break
}

set appdir [file dir $script]
lappend auto_path $appdir/lib
package require Extral

# generic help on no args
if {[llength $argv] < 1} {
puts {Use
cg sortgene gene_file sorted_gene_file
cg var2annot variation_file sorted_gene_file output_file
}
exit 1
}

set action [list_shift argv]
switch $action {
	multicompar {
		if {([llength $argv] < 1)} {
			puts stderr "format is: $scriptname $action compar_file ?dir? ..."
			puts stderr " - adds new sample dir(s) to compar_file"
			puts stderr " - the sample dir(s) should be one directory below compar_file"
			puts stderr " - sample names will be the names of the sample dir(s)"
			puts stderr " - if no dirs are given, missing annotations will be checked and added"
			exit 1
		}
		foreach {compar_file} $argv break
		set dirs [lrange $argv 1 end]
		foreach dir $dirs {
			putslog "Adding $dir"
			multicompar $compar_file $dir
		}
		putslog "Reannotating $compar_file"
		multicompar_reannot $compar_file
	}
	process_sample {
		if {([llength $argv] < 2) || ([llength $argv] > 3)} {
			puts stderr "format is: $scriptname $action sampledir dbdir ?force?"
			puts stderr " - processes (sorting annotating, etc.) one sample directory."
			puts stderr " - By default, only files that are not present already will be created."
			puts stderr " -When force is given as a parameter, everything will be recalculated and overwritten."
			exit 1
		}
		foreach {dir dbdir force} $argv break
		switch $force {
			force {set force 1}
			"" {set force 0}
			default {error "unrecognized option $force"}
		}
		process_sample $dir $dbdir $force
	}
	process_rtgsample {
		if {([llength $argv] < 2) || ([llength $argv] > 3)} {
			puts stderr "format is: $scriptname $action sampledir dbdir ?force?"
			puts stderr " - processes (sorting annotating, etc.) one rtg sample directory."
			puts stderr " - By default, only files that are not present already will be created."
			puts stderr " -When force is given as a parameter, everything will be recalculated and overwritten."
			exit 1
		}
		foreach {dir dbdir force} $argv break
		switch $force {
			force {set force 1}
			"" {set force 0}
			default {error "unrecognized option $force"}
		}
		process_rtgsample $dir $dbdir $force
	}
	process_compare {
		if {[llength $argv] == 2} {
			set force 0
			foreach {dbdir resultsdir} $argv break
			foreach {dir1 dir2} [lrange [split $resultsdir _] end-1 end] break
			set dir1 [file dir $resultsdir]/$dir1
			set dir2 [file dir $resultsdir]/$dir2
		} else {
			if {([llength $argv] < 4) || ([llength $argv] > 5)} {
				puts stderr "format is: $scriptname $action sampledir1 sampledir2 dbdir resultsdir ?force?"
				puts stderr " - compare 2 (prepared) sample directories."
				puts stderr " - By default, only files that are not present already will be created."
				puts stderr " -When force is given as a parameter, everything will be recalculated and overwritten."
				exit 1
			}
			foreach {dir1 dir2 dbdir resultsdir force} $argv break
			switch $force {
				force {set force 1}
				"" {set force 0}
				default {error "unrecognized option $force"}
			}
		}
		process_compare $dir1 $dir2 $dbdir $resultsdir $force
	}
	process_compare_coverage {
		if {[llength $argv] == 2} {
			set force 0
			foreach {dbdir resultsdir} $argv break
			foreach {dir1 dir2} [lrange [split $resultsdir _] end-1 end] break
			set dir1 [file dir $resultsdir]/$dir1
			set dir2 [file dir $resultsdir]/$dir2
		} else {
			if {([llength $argv] < 4) || ([llength $argv] > 5)} {
				puts stderr "format is: $scriptname $action sampledir1 sampledir2 dbdir resultsdir ?force?"
				puts stderr " - calculate coverages for 2 compared sample directories."
				puts stderr " - By default, only files that are not present already will be created."
				puts stderr " -When force is given as a parameter, everything will be recalculated and overwritten."
				exit 1
			}
			foreach {dir1 dir2 dbdir resultsdir force} $argv break
			switch $force {
				force {set force 1}
				"" {set force 0}
				default {error "unrecognized option $force"}
			}
		}
		process_compare_coverage $dir1 $dir2 $dbdir $resultsdir $force
	}
	process_indexcompress {
		if {[llength $argv] != 1} {
			puts stderr "format is: $scriptname $action file"
			puts stderr " - makes index, and compresses to razip"
			exit 1
		}
		foreach {file} $argv break
		process_indexcompress $file
	}
	var2annot {
		if {[llength $argv] != 3} {
			puts stderr "format is: $scriptname $action variation_file sorted_gene_file output_file"
			puts stderr " - makes a new variation file, where the gene information is included"
			exit 1
		}
		foreach {file genefile outfile} $argv break
		var2annotvar $file $genefile $outfile
	}
	compare_annot {
		if {[llength $argv] != 7} {
			puts stderr "format is: $scriptname $action id1 annot_varfile1 region_file1 id2 annot_varfile2 region_file2 outfile"
			exit 1
		}
		foreach {id1 file1 regfile1 id2 file2 regfile2 outfile} $argv break
		compare_annot $id1 $file1 $regfile1 $id2 $file2 $regfile2 $outfile
	}
	annot_compare_region {
		if {[llength $argv] != 5} {
			puts stderr "format is: $scriptname $action compar_file reg_file field tvalue fvalue"
			exit 1
		}
		foreach {compar_file reg_file field tvalue fvalue} $argv break
		annot_compare_region $compar_file $reg_file $field $tvalue $fvalue
	}
	compare_pvt {
		if {[llength $argv] != 0} {
			puts stderr "format is: $scriptname $action"
			exit 1
		}
		compare_pvt
	}
	compare_pvtsummary {
		if {[llength $argv] != 0 && [llength $argv] != 1} {
			puts stderr "format is: $scriptname $action ?table?"
			exit 1
		}
		if {[lindex $argv end] eq "table"} {set type 2} else {set type 1}
		compare_pvtsummary $type
	}
	cg2cnv {
		if {[llength $argv] != 2} {
			puts stderr "format is: $scriptname $action dir outdir"
			exit 1
		}
		foreach {dir outdir} $argv break
		cg2cnv $dir $outdir
	}
	cnv-seq {
		if {[llength $argv] != 3} {
			puts stderr "format is: $scriptname $action refdir testdir outdir"
			exit 1
		}
		foreach {ref test outdir} $argv break
		cnvseq $ref $test $outdir
	}
	map2sv {
		if {[llength $argv] < 2} {
			puts stderr "format is: $scriptname $action file ... out_prefix"
			exit 1
		}
		set prefix [list_pop argv]
		map2sv $argv $prefix
	}
	sv2db {
		if {[llength $argv] < 1} {
			puts stderr "format is: $scriptname $action file ..."
			exit 1
		}
		sv2db $argv
	}
	svinfo {
		if {[llength $argv] < 1} {
			puts stderr "format is: $scriptname $action file ..."
			exit 1
		}
		foreach pairfile $argv {
			putslog $pairfile
			svinfo $pairfile
		}
	}
	svfind {
		if {[llength $argv] != 2} {
			puts stderr "format is: $scriptname $action pairedfile trffile"
			exit 1
		}
		foreach {pairfile trffile} $argv break
		putslog $pairfile
		svfind $pairfile $trffile
	}
	svcompare {
		if {[llength $argv] != 2} {
			puts stderr "format is: $scriptname $action svfile1 svfile2"
			exit 1
		}
		foreach {svfile1 svfile2} $argv break
		svcompare $svfile1 $svfile2
	}
	svrescore {
		if {[llength $argv] != 1} {
			puts stderr "format is: $scriptname $action svfile"
			exit 1
		}
		foreach {svfile} $argv break
		svrescore $svfile
	}
	covered {
		if {[llength $argv] != 1} {
			puts stderr "format is: $scriptname $action region_file"
			exit 1
		}
		foreach {regfile} $argv break
		covered $regfile
	}
	refconsregions {
		if {[llength $argv] != 1} {
			puts stderr "format is: $scriptname $action variation_file"
			puts stderr " - outputs regions annotated as ref-(in)consistent from variation file"
			exit 1
		}
		foreach {varfile} $argv break
		refconsregions $varfile
	}
	clusterregions {
		if {[llength $argv] != 0} {
			puts stderr "format is: $scriptname $action"
			puts stderr " - outputs regions with clusters of variations"
			puts stderr " - input is an annotated variations file"
			exit 1
		}
		clusters
	}
	regsubtract {
		if {[llength $argv] != 2} {
			puts stderr "format is: $scriptname $action region_file1 region_file2"
			puts stderr " - outputs regions region_file1 from which the regions in region_file2 are removed"
			exit 1
		}
		foreach {region_file1 region_file2} $argv break
		regsubtract $region_file1 $region_file2
	}
	regjoin {
		if {([llength $argv] != 1) && ([llength $argv] != 2)} {
			puts stderr "format is: $scriptname $action region_file1 ?region_file2?"
			puts stderr "outputs joined regions from region_file1 and (optionally) region_file2."
			puts stderr "Both files must be sorted."
			exit 1
		}
		foreach {region_file1 region_file2} $argv break
		regjoin $region_file1 $region_file2
	}
	reghisto {
		if {[llength $argv] != 1} {
			puts stderr "format is: $scriptname $action region_file"
			puts stderr ""
			exit 1
		}
		foreach {region_file} $argv break
		reghisto $region_file
	}
	makeregions {
		if {[llength $argv] != 2} {
			puts stderr "format is: $scriptname $action selvariationfile maxsize"
			exit 1
		}
		foreach {selvariationfile maxsize} $argv break
		makeprimers_makeregions $selvariationfile $maxsize
	}
	makeprimers {
		if {[llength $argv] != 6} {
			puts stderr "format is: $scriptname $action regionfile archive maxsize prefsize db threads"
			puts stderr "regionfile has to have the columns chromosome, begin, end; must be sorted by chromosome, then begin"
			puts stderr "archive is may2009 for cgi, empty for latest"
			puts stderr "maxsize is the maximum amplicon size"
			puts stderr "prefsize is the prefered amplicon size"
			puts stderr "db a blastable database of the human genome, right build, names are chromosomes"
			exit 1
		}
		foreach {regionfile archive maxsize prefsize db threads} $argv break
		makeprimers $regionfile $archive $maxsize $prefsize $db $threads
	}
	graph {
		package require Tk
		set object .g
		graphwidget .g
		pack .g -fill both -expand yes
		if {[lindex $argv 0] eq "region"} {
			list_shift argv
			set region 1
		} else {
			set region 0
		}
		foreach file $argv {
			.g open $file $region
		}
	}
	ucsc2region {
		if {[llength $argv] != 1} {
			puts stderr "format is: $scriptname $action ucsc_file"
			puts stderr "convert ucsc tab file to regionfile for further use in filtering"
			exit 1
		}
		foreach {ucsc_file} $argv break
		ucsc2region $ucsc_file
	}
	tosqlite {
		if {[llength $argv] != 3} {
			puts stderr "format is: $scriptname $action dbfile table tsvfile"
			exit 1
		}
		foreach {dbfile table tsvfile} $argv break
		set f [open $tsvfile]
		set header [split [gets $f] \t]
		set line [split [gets $f] \t]
		close $f
		set sql ""
		foreach field $header v $line {
			if {[isint $v]} {
				set type integer
			} elseif {[isdouble $v]} {
				set type real
			} else {
				set type text
			}
			lappend sql "\"$field\" $type"
		}
		set sql "create table $table ([join $sql ,])"
		package require dbi
		package require dbi_sqlite3
		dbi_sqlite3 db
		db create $dbfile
		db open $dbfile
		db exec $sql
		db import abort compar $tsvfile \t {}
		db close
	}
	tsv_index {
		if {[llength $argv] < 2} {
			puts stderr "format is: $scriptname $action field tsvfile ..."
			exit 1
		}
		set field [list_shift argv]
		foreach tsvfile $argv {
			tsv_index $tsvfile $field
		}
	}
	select {
		set query {}; set fields {}; set sortfields {}
		if {[expr {[llength $argv]%2}]} {
			set filename [list_pop argv]
			set f [rzopen $filename]
		} else {
			set f stdin
		}
		foreach {key value} $argv {
			switch -- $key {
				-q {
					set query $value
					if {[regexp {[^=!><]=[^=]} $query]} {puts stderr "you used = instead of == in query"; exit 1}
				}
				-f {set fields $value}
				-s {set sortfields $value}
				-h {
					set header [tsv_open stdin]
					puts stdout $header
					exit 1
				}
				default {
					puts stderr "unkown option $key"
					puts stderr "format is: $scriptname $action ?-q query? ?-f fields? ?-s sortfields? ?filename?"
					puts stderr " - select lines and columns in tab separated file, and sorts the result"
					puts stderr "or format is: $scriptname $action -h"
					puts stderr " - return header fields in file"
					exit 1
				}
			}
		}
		set error [catch {tsv_select $query $fields $sortfields $f} result]
		if {$f ne "stdin"} {catch {close $f}}
		if {$error} {
			puts stderr $result
			exit 1
		}
	}
	sort {
		if {([llength $argv] < 1) || ([llength $argv] > 2)} {
			puts stderr "format is: $scriptname $action file fields"
			puts stderr " - sort tab separated file"
			exit 1
		}
		foreach {filename fields} $argv break
		tsv_sort $filename $fields
	}
	scoredist {
		if {[llength $argv] < 1} {
			puts stderr "format is: $scriptname $action compar_file ..."
			puts stderr " - calculates distribution of different scores"
			exit 1
		}
		foreach {filename} $argv {
			scoredist $filename
		}
	}
	default {
		puts stderr "unkown option $action"
		exit 1
	}
}

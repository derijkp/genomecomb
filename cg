#!/bin/sh
# the next line restarts using wish \
exec tclsh "$0" ${1+"$@"}

# see where we are, add the lib dir in the original location to auto_path, load extension
set script [file normalize [info script]]
set scriptname [file tail $script]
while 1 {
	if {[catch {set script [file normalize [file readlink $script]]}]} break
}

set appdir [file dir $script]
lappend auto_path $appdir/lib
package require Extral

# generic help on no args
if {[llength $argv] < 1} {
puts {Use
cg sortgene gene_file sorted_gene_file
cg var2annot variation_file sorted_gene_file output_file
}
exit 1
}

set action [list_shift argv]
switch $action {
	sortgene {
		if {[llength $argv] != 2} {
			puts stderr "format is: $scriptname $action gene_file sorted_gene_file"
			exit 1
		}
		foreach {gene_file sorted_gene_file} $argv break
		exec head -12 $gene_file > $sorted_gene_file
		exec tail +13 $gene_file | sort -nk2 >> $sorted_gene_file
	}
	sortvar {
		if {[llength $argv] != 2} {
			puts stderr "format is: $scriptname $action var_file sorted_var_file"
			exit 1
		}
		foreach {var_file sorted_var_file} $argv break
		set f [opencgifile $var_file header numlines]
		close $f
		file_write $sorted_var_file [join $header \t]\n
		incr numlines
		file mkdir tmp
		exec distr2chr tmp/d$var_file 2 < $var_file
		set files [lsort -dictionary [glob tmp/d$var_file-\[0-9\]*]]
		eval exec cat $files > $sorted_var_file
		set chr X
		exec sort -nk4 tmp/d$var_file-$chr >> $sorted_var_file
		exec cat tmp/d$var_file-Y >> $sorted_var_file
		exec cat tmp/d$var_file-M >> $sorted_var_file
		set files [lsort -dictionary [glob tmp/d$var_file-*]]
		foreach file $files {file delete $file}
	}
	var2annot {
		if {[llength $argv] != 3} {
			puts stderr "format is: $scriptname $action variation_file sorted_gene_file output_file"
			exit 1
		}
		foreach {file genefile outfile} $argv break
		var2annotvar $file $genefile $outfile
	}
	compare_annot {
		if {[llength $argv] != 7} {
			puts stderr "format is: $scriptname $action id1 annot_varfile1 region_file1 id2 annot_varfile2 region_file2 output_prefix"
			exit 1
		}
		foreach {id1 file1 regfile1 id2 file2 regfile2 output_prefix} $argv break
		compare_annot $id1 $file1 $regfile1 $id2 $file2 $regfile2 $output_prefix
		file delete -force ${output_prefix}summary.tsv
		puts "Making summaries"
		file delete -force ${output_prefix}summary.tsv
		comstats ${output_prefix}summary.tsv ${output_prefix}diff.tsv
		comstats ${output_prefix}summary.tsv ${output_prefix}mismatch.tsv
		comstats ${output_prefix}summary.tsv ${output_prefix}same.tsv
		comstats ${output_prefix}summary.tsv ${output_prefix}uniqueseq.tsv
	}
	compare_summary {
		if {[llength $argv] != 1} {
			puts stderr "format is: $scriptname $action output_prefix"
			exit 1
		}
		foreach {output_prefix} $argv break
		file delete -force ${output_prefix}summary.tsv
		comstats ${output_prefix}summary.tsv ${output_prefix}diff.tsv
		comstats ${output_prefix}summary.tsv ${output_prefix}mismatch.tsv
		comstats ${output_prefix}summary.tsv ${output_prefix}same.tsv
		comstats ${output_prefix}summary.tsv ${output_prefix}uniqueseq.tsv
	}
	cg2cnv {
		if {[llength $argv] != 2} {
			puts stderr "format is: $scriptname $action dir outdir"
			exit 1
		}
		foreach {dir outdir} $argv break
		cg2cnv $dir $outdir
	}
	cnv-seq {
		if {[llength $argv] != 3} {
			puts stderr "format is: $scriptname $action refdir testdir outdir"
			exit 1
		}
		foreach {ref test outdir} $argv break
		cnvseq $ref $test $outdir
	}
	map2sv {
		if {[llength $argv] < 2} {
			puts stderr "format is: $scriptname $action file ... out_prefix"
			exit 1
		}
		set prefix [list_pop argv]
		map2sv $argv $prefix
	}
	sv2db {
		if {[llength $argv] < 1} {
			puts stderr "format is: $scriptname $action file ..."
			exit 1
		}
		sv2db $argv
	}
	svdbinfo {
		if {[llength $argv] < 1} {
			puts stderr "format is: $scriptname $action file ..."
			exit 1
		}
		foreach dbfile $argv {
			puts $dbfile
			svdbinfo $dbfile
		}
	}
	covered {
		if {[llength $argv] != 1} {
			puts stderr "format is: $scriptname $action region_file"
			exit 1
		}
		foreach {regfile} $argv break
		covered $regfile
	}
	refconsregions {
		if {[llength $argv] != 1} {
			puts stderr "format is: $scriptname $action variation_file"
			puts stderr "outputs regions annotated as ref-(in)consistent from variation file"
			exit 1
		}
		foreach {varfile} $argv break
		refconsregions $varfile
	}
	regsubtract {
		if {[llength $argv] != 2} {
			puts stderr "format is: $scriptname $action region_file1 region_file2"
			puts stderr "outputs regions region_file1 from which the regions in region_file2 are removed"
			exit 1
		}
		foreach {region_file1 region_file2} $argv break
		regsubtract $region_file1 $region_file2
	}
	reghisto {
		if {[llength $argv] != 1} {
			puts stderr "format is: $scriptname $action region_file"
			puts stderr ""
			exit 1
		}
		foreach {region_file} $argv break
		reghisto $region_file
	}
	makeregions {
		if {[llength $argv] != 2} {
			puts stderr "format is: $scriptname $action selvariationfile maxsize"
			exit 1
		}
		foreach {selvariationfile maxsize} $argv break
		makeprimers_makeregions $selvariationfile $maxsize
	}
	makeprimers {
		if {[llength $argv] != 6} {
			puts stderr "format is: $scriptname $action regionfile archive maxsize prefsize db threads"
			puts stderr "regionfile has to have the columns chromosome, begin, end; must be sorted by chromosome, then begin"
			puts stderr "archive is may2009 for cgi, empty for latest"
			puts stderr "maxsize is the maximum amplicon size"
			puts stderr "prefsize is the prefered amplicon size"
			puts stderr "db a blastable database of the human genome, right build, names are chromosomes"
			exit 1
		}
		foreach {regionfile archive maxsize prefsize db threads} $argv break
		makeprimers $regionfile $archive $maxsize $prefsize $db $threads
	}
	graph {
		package require Tk
		set object .g
		graphwidget .g
		pack .g -fill both -expand yes
	}
	default {
		puts stderr "unkown option $action"
		exit 1
	}
}

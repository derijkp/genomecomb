#!/bin/sh
# the next line restarts using wish \
exec tclsh "$0" ${1+"$@"}

# see where we are, add the lib dir in the original location to auto_path, load extension
set script [file normalize [info script]]
set scriptname [file tail $script]
while 1 {
	if {[catch {set script [file normalize [file readlink $script]]}]} break
}

set appdir [file dir $script]
lappend auto_path $appdir/lib
append env(PATH) :[file dir [file dir $appdir]]/bin:$appdir/bin
package require Extral

# generic help on no args
if {[llength $argv] < 1} {
puts {No option given, format is:
cg option ....
possible options are: select, graph, annotate, multicompar, process_sample,
covered, regsubtract, regjoin, regcommon, 
makeregions, makeprimers, ...
}
exit 1
}

set action [list_shift argv]
switch $action {
	multicompar {
		if {([llength $argv] < 1)} {
			puts stderr "format is: $scriptname $action compar_file ?dir? ..."
			puts stderr " - adds new sample dir(s) to compar_file"
			puts stderr " - the sample dir(s) should be one directory below compar_file (for reannot)"
			puts stderr " - sample names will be the names of the sample dir(s)"
			puts stderr " - missing annotations must be checked and added afterwards using multicompar_reannot"
			exit 1
		}
		set regonly 0
		if {[lindex $argv 0] eq "-reannot"} {
			putslog "Also reannot"
			set reannot 1
			set argv [lrange $argv 1 end]
		} elseif {[lindex $argv 0] eq "-reannotregonly"} {
			putslog "Also reannot"
			set reannot 1
			set regonly 1
			set argv [lrange $argv 1 end]
		} else {
			set reannot 0
		}
		foreach {compar_file} $argv break
		set dirs [lrange $argv 1 end]
		foreach dir $dirs {
			putslog "Adding $dir"
			multicompar $compar_file $dir
		}
		if {$reannot} {
			putslog "Reannotating $compar_file"
			multicompar_reannot $compar_file 0 $regonly
		}
	}
	multicompar_reannot {
		if {([llength $argv] != 1) && ([llength $argv] != 2)} {
			puts stderr "format is: $scriptname $action compar_file ?force? ?regonly?"
			puts stderr " - reannotate multicompar file"
			puts stderr " - unless the force option is used, only unfilled (?) cells will be updated"
			puts stderr " - if the regonly option is used, only region data (sequenced) will be updated"
			exit 1
		}
		set compar_file [list_shift argv]
		set force 0
		set regonly 0
		foreach option $argv {
			switch $option {
				force {set force 1}
				regonly {set regonly 1}
				default {error "unrecognized option $option"}
			}
		}
		putslog "Reannotating $compar_file"
		multicompar_reannot $compar_file $force $regonly
	}
	process_sample {
		if {([llength $argv] < 2) || ([llength $argv] > 3)} {
			puts stderr "format is: $scriptname $action sampledir destdir dbdir ?force?"
			puts stderr " - processes (sorting annotating, etc.) one sample directory."
			puts stderr " - By default, only files that are not present already will be created."
			puts stderr " -When force is given as a parameter, everything will be recalculated and overwritten."
			exit 1
		}
		foreach {dir destdir dbdir force} $argv break
		switch $force {
			force {set force 1}
			"" {set force 0}
			default {error "unrecognized option $force"}
		}
		process_sample $dir $destdir $dbdir $force
	}
	process_rtgsample {
		if {([llength $argv] < 2) || ([llength $argv] > 3)} {
			puts stderr "format is: $scriptname $action sampledir dbdir ?force?"
			puts stderr " - processes (sorting annotating, etc.) one rtg sample directory."
			puts stderr " - By default, only files that are not present already will be created."
			puts stderr " -When force is given as a parameter, everything will be recalculated and overwritten."
			exit 1
		}
		foreach {dir dbdir force} $argv break
		switch $force {
			force {set force 1}
			"" {set force 0}
			default {error "unrecognized option $force"}
		}
		process_rtgsample $dir $dbdir $force
	}
	process_sv {
		if {([llength $argv] < 2) || ([llength $argv] > 3)} {
			puts stderr "format is: $scriptname $action sampledir destdir dbdir ?force?"
			puts stderr " - processes sv for one sample directory."
			puts stderr " - By default, only files that are not present already will be created."
			puts stderr " -When force is given as a parameter, everything will be recalculated and overwritten."
			exit 1
		}
		foreach {dir destdir dbdir force} $argv break
		switch $force {
			force {set force 1}
			"" {set force 0}
			default {error "unrecognized option $force"}
		}
		process_sv $dir $destdir $dbdir $force
	}
	rtgregions {
		if {[llength $argv] != 3} {
			puts stderr "format is: $scriptname $action cgdir comparfile rtgdir"
			exit 1
		}
		foreach {cgdir comparfile rtgdir} $argv break
		rtgregions $cgdir $comparfile $rtgdir
	}
	process_compare {
		if {[llength $argv] == 2} {
			set force 0
			foreach {dbdir resultsdir} $argv break
			set resultsdir [file normalize $resultsdir]
			foreach {dir1 dir2} [lrange [split $resultsdir _] end-1 end] break
			set dir1 [file dir $resultsdir]/$dir1
			set dir2 [file dir $resultsdir]/$dir2
		} else {
			if {([llength $argv] < 4) || ([llength $argv] > 5)} {
				puts stderr "format is: $scriptname $action sampledir1 sampledir2 dbdir resultsdir ?force?"
				puts stderr " - compare 2 (prepared) sample directories."
				puts stderr " - By default, only files that are not present already will be created."
				puts stderr " -When force is given as a parameter, everything will be recalculated and overwritten."
				exit 1
			}
			foreach {dir1 dir2 dbdir resultsdir force} $argv break
			switch $force {
				force {set force 1}
				"" {set force 0}
				default {error "unrecognized option $force"}
			}
		}
		process_compare $dir1 $dir2 $dbdir $resultsdir $force
	}
	process_compare_coverage {
		if {[llength $argv] == 2} {
			set force 0
			foreach {dbdir resultsdir} $argv break
			set dbdir [file normalize $dbdir]
			set resultsdir [file normalize $resultsdir]
			foreach {dir1 dir2} [lrange [split $resultsdir _] end-1 end] break
			set dir1 [file dir $resultsdir]/$dir1
			set dir2 [file dir $resultsdir]/$dir2
			set resultsdir $resultsdir/genomecoverage
			file mkdir $resultsdir
		} else {
			if {([llength $argv] < 4) || ([llength $argv] > 5)} {
				puts stderr "format is: $scriptname $action sampledir1 sampledir2 dbdir resultsdir ?force?"
				puts stderr " - calculate coverages for 2 compared sample directories."
				puts stderr " - By default, only files that are not present already will be created."
				puts stderr " -When force is given as a parameter, everything will be recalculated and overwritten."
				exit 1
			}
			foreach {dir1 dir2 dbdir resultsdir force} $argv break
			switch $force {
				force {set force 1}
				"" {set force 0}
				default {error "unrecognized option $force"}
			}
		}
		process_compare_coverage $dir1 $dir2 $dbdir $resultsdir $force
	}
	process_indexcompress {
		if {[llength $argv] != 1} {
			puts stderr "format is: $scriptname $action file"
			puts stderr " - makes index, and compresses to razip"
			exit 1
		}
		foreach {file} $argv break
		process_indexcompress $file
	}
	var2annot {
		if {[llength $argv] != 3} {
			puts stderr "format is: $scriptname $action variation_file sorted_gene_file output_file"
			puts stderr " - makes a new variation file, where the gene information is included"
			exit 1
		}
		foreach {file genefile outfile} $argv break
		var2annotvar $file $genefile $outfile
	}
	compare_annot {
		if {[llength $argv] != 7} {
			puts stderr "format is: $scriptname $action id1 annot_varfile1 region_file1 id2 annot_varfile2 region_file2 outfile"
			exit 1
		}
		foreach {id1 file1 regfile1 id2 file2 regfile2 outfile} $argv break
		compare_annot $id1 $file1 $regfile1 $id2 $file2 $regfile2 $outfile
	}
	annot_compare_region {
		if {[llength $argv] != 5} {
			puts stderr "format is: $scriptname $action compar_file reg_file field tvalue fvalue"
			exit 1
		}
		foreach {compar_file reg_file field tvalue fvalue} $argv break
		annot_compare_region $compar_file $reg_file $field $tvalue $fvalue
	}
	compare_pvt {
		if {[llength $argv] != 0} {
			puts stderr "format is: $scriptname $action"
			exit 1
		}
		compare_pvt
	}
	compare_pvtsummary {
		if {[llength $argv] != 0 && [llength $argv] != 1} {
			puts stderr "format is: $scriptname $action ?table?"
			exit 1
		}
		if {[lindex $argv end] eq "table"} {set type 2} else {set type 1}
		compare_pvtsummary $type
	}
	compare_mpvt {
		if {[llength $argv] < 1} {
			puts stderr "format is: $scriptname $action multicomparfile mpvtfile"
			puts stderr " - returns mpvt file with numbers per class of variant"
			puts stderr " - The samples used in the comparison are taken from the name"
			puts stderr " - of the resulting mpvtfile that has the following pattern"
			puts stderr " - prefix_sample1_sample2_....tsv"
			exit 1
		}
		foreach {dbdir resultsdir} $argv break
		compare_mpvt {*}$argv
	}
	mpvt_summary {
		if {[llength $argv] != 2} {
			puts stderr "format is: $scriptname $action mpvtfile prefix_sample1_sample2_rtgsample1_rtgsample2.tsv"
			puts stderr " - Creates a summary file (last argument)"
			puts stderr " - The name consists of a prefix followed by the samples to be compared (joined with _)"
			exit 1
		}
		mpvt_summary {*}$argv
	}
	cg2cnv {
		if {[llength $argv] != 2} {
			puts stderr "format is: $scriptname $action dir outdir"
			exit 1
		}
		foreach {dir outdir} $argv break
		cg2cnv $dir $outdir
	}
	cnv-seq {
		if {[llength $argv] != 3} {
			puts stderr "format is: $scriptname $action refdir testdir outdir"
			exit 1
		}
		foreach {ref test outdir} $argv break
		cnvseq $ref $test $outdir
	}
	map2sv {
		if {[llength $argv] < 2} {
			puts stderr "format is: $scriptname $action file ... out_prefix"
			exit 1
		}
		set prefix [list_pop argv]
		map2sv $argv $prefix
	}
	sv2db {
		if {[llength $argv] < 1} {
			puts stderr "format is: $scriptname $action file ..."
			exit 1
		}
		sv2db $argv
	}
	svinfo {
		if {[llength $argv] < 1} {
			puts stderr "format is: $scriptname $action file ..."
			exit 1
		}
		foreach pairfile $argv {
			putslog $pairfile
			svinfo $pairfile
		}
	}
	svfind {
		if {[llength $argv] < 2} {
			puts stderr "format is: $scriptname $action pairedfile ... trffile"
			exit 1
		}
		set trffile [list_pop argv]
		foreach {pairfile} $argv {
			putslog $pairfile
			svfind $pairfile $trffile
		}
	}
	svcompare {
		if {[llength $argv] != 2} {
			puts stderr "format is: $scriptname $action svfile1 svfile2"
			exit 1
		}
		foreach {svfile1 svfile2} $argv break
		svcompare $svfile1 $svfile2
	}
	svrescore {
		if {[llength $argv] != 1} {
			puts stderr "format is: $scriptname $action svfile"
			exit 1
		}
		foreach {svfile} $argv break
		svrescore $svfile
	}
	covered {
		if {[llength $argv] != 1} {
			puts stderr "format is: $scriptname $action region_file"
			exit 1
		}
		foreach {regfile} $argv break
		covered $regfile
	}
	refconsregions {
		if {[llength $argv] != 1} {
			puts stderr "format is: $scriptname $action variation_file"
			puts stderr " - outputs regions annotated as ref-(in)consistent from variation file"
			exit 1
		}
		foreach {varfile} $argv break
		refconsregions $varfile
	}
	clusterregions {
		if {[llength $argv] != 0} {
			puts stderr "format is: $scriptname $action"
			puts stderr " - outputs regions with clusters of variations"
			puts stderr " - input is an annotated variations file"
			exit 1
		}
		clusters
	}
	regsubtract {
		if {[llength $argv] != 2} {
			puts stderr "format is: $scriptname $action region_file1 region_file2"
			puts stderr " - outputs regions region_file1 from which the regions in region_file2 are removed"
			exit 1
		}
		foreach {region_file1 region_file2} $argv break
		regsubtract $region_file1 $region_file2
	}
	regjoin {
		if {([llength $argv] != 1) && ([llength $argv] != 2)} {
			puts stderr "format is: $scriptname $action region_file1 ?region_file2?"
			puts stderr "outputs joined regions from region_file1 and (optionally) region_file2."
			puts stderr "Both files must be sorted."
			exit 1
		}
		foreach {region_file1 region_file2} $argv break
		regjoin $region_file1 $region_file2
	}
	regcommon {
		if {([llength $argv] != 1) && ([llength $argv] != 2)} {
			puts stderr "format is: $scriptname $action region_file1 region_file2"
			puts stderr "outputs lists regions common between region_file1 and region_file2."
			puts stderr "Both files must be sorted and regjoined."
			exit 1
		}
		foreach {region_file1 region_file2} $argv break
		set tempfile [tempfile]
		cg regsubtract $region_file1 $region_file2 > $tempfile
		cg regsubtract $region_file1 $tempfile >@ stdout
	}
	reghisto {
		if {[llength $argv] != 1} {
			puts stderr "format is: $scriptname $action region_file"
			puts stderr ""
			exit 1
		}
		foreach {region_file} $argv break
		reghisto $region_file
	}
	makeregions {
		if {[llength $argv] != 2} {
			puts stderr "format is: $scriptname $action selvariationfile maxsize"
			exit 1
		}
		foreach {selvariationfile maxsize} $argv break
		makeprimers_makeregions $selvariationfile $maxsize
	}
	makeprimers {
		if {[llength $argv] != 6} {
			puts stderr "format is: $scriptname $action regionfile archive maxsize prefsize db threads"
			puts stderr "regionfile has to have the columns chromosome, begin, end; must be sorted by chromosome, then begin"
			puts stderr "archive is may2009 for cgi, empty for latest"
			puts stderr "maxsize is the maximum amplicon size"
			puts stderr "prefsize is the prefered amplicon size"
			puts stderr "db is a searchable database (ssa) of the human genome (/complgen/refseq/hg18/build36-ssa)"
			exit 1
		}
		foreach {regionfile archive maxsize prefsize db threads} $argv break
		makeprimers $regionfile $archive $maxsize $prefsize $db $threads
	}
	graph {
		package require Tk
		set object .g
		graphwidget .g
		pack .g -fill both -expand yes
		if {[lindex $argv 0] eq "region"} {
			list_shift argv
			set region 1
		} else {
			set region 0
		}
		foreach file $argv {
			.g open $file $region
		}
	}
	ucsc2region {
		if {[llength $argv] != 1} {
			puts stderr "format is: $scriptname $action ucsc_file"
			puts stderr "convert ucsc tab file to regionfile for further use in filtering"
			exit 1
		}
		foreach {ucsc_file} $argv break
		ucsc2region $ucsc_file
	}
	tosqlite {
		if {[llength $argv] != 3} {
			puts stderr "format is: $scriptname $action dbfile table tsvfile"
			exit 1
		}
		foreach {dbfile table tsvfile} $argv break
		set f [open $tsvfile]
		set header [split [gets $f] \t]
		set line [split [gets $f] \t]
		close $f
		set sql ""
		foreach field $header v $line {
			if {[isint $v]} {
				set type integer
			} elseif {[isdouble $v]} {
				set type real
			} else {
				set type text
			}
			lappend sql "\"$field\" $type"
		}
		set sql "create table $table ([join $sql ,])"
		catch {package require dbi}
		package require dbi_sqlite3
		dbi_sqlite3 db
		db create $dbfile
		db open $dbfile
		db exec $sql
		db import abort compar $tsvfile \t {}
		db close
	}
	tsv_index {
		if {[llength $argv] < 2} {
			puts stderr "format is: $scriptname $action field tsvfile ..."
			exit 1
		}
		set field [list_shift argv]
		foreach tsvfile $argv {
			putslog "Indexing $tsvfile"
			tsv_index $field $tsvfile
		}
	}
	tsv_align {
		if {[llength $argv] < 6} {
			puts stderr "format is: $scriptname $action file1 file2 joinfields1 joinfields2 postfix1 postfix2 ?method?"
			exit 1
		}
		foreach {file1 file2 joinfields1 joinfields2 postfix1 postfix2 method} $argv break
		if {$method eq ""} {set method match}
		switch $method {
			match {tsv_align $file1 $file2 $joinfields1 $joinfields2 $postfix1 $postfix2}
		}
	}
	sort {
		if {([llength $argv] < 1) || ([llength $argv] > 2)} {
			puts stderr "format is: $scriptname $action file fields"
			puts stderr " - sort tab separated file"
			exit 1
		}
		foreach {filename fields} $argv break
		tsv_sort $filename $fields
	}
	scoredist {
		if {[llength $argv] != 3} {
			puts stderr "format is: $scriptname $action compar_file sample1 sample2"
			puts stderr " - calculates distribution of different scores"
			exit 1
		}
		foreach {filename sample1 sample2} $argv {
			scoredist $filename $sample1 $sample2
		}
	}
	addgeneinfo {
		if {[llength $argv] != 1} {
			puts stderr "format is: $scriptname $action file"
			puts stderr " - add gene description"
			exit 1
		}
		foreach {filename} $argv break
		set f [open $filename]
		set line [split [gets $f] \t]
		set idpos [lsearch $line geneId]
		puts [join $line \t]\tgenedescr
		while {![eof $f]} {
			set line [split [gets $f] \t]
			set id [lindex $line $idpos]
			set descr [ncbi_getgene $id]
			puts [join $line \t]\t$descr
		}
	}
	getembl {
		if {[llength $argv] < 2 && [llength $argv] > 3} {
			puts stderr "format is: $scriptname $action regionsfile archive ?extraseq?"
			puts stderr " - get emblfiles"
			exit 1
		}
		foreach {regionsfile archive extraseq} $argv break
		if {![isint $extraseq]} {set extraseq 50000}
		set list [file_read $regionsfile]
		set regions [split $list \n]
		list_shift regions
		list_foreach {cchr cstart cend} $regions {
			set cchr [string range $cchr 3 end]
			set filename $cchr-[expr {$cstart-$extraseq}]-[expr {$cend+$extraseq}].embl
			if {[file exists $filename]} {
				puts "$filename already done"
				continue
			}
			puts $cchr:$cstart-$cend
			set embl [ensembl_getregion $cchr [expr {$cstart-$extraseq}] [expr {$cend+$extraseq}] -archive $archive]
			file_write $filename $embl
		}
		
	}
	default {
		set args $argv
		unset -nocomplain argv
		if {[auto_load cg_$action]} {
			set ::base "cg $action"
			cg_$action {*}$args
		} else {
			puts stderr "unkown option $action"
			exit 1
		}
	}
}
